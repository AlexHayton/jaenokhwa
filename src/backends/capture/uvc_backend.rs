use crate::{CameraFormat, CameraInfo, CaptureBackendTrait, FrameFormat, NokhwaError, Resolution};
use flume::{Receiver, Sender};
use image::{ImageBuffer, Rgb};
use ouroboros::self_referencing;
use std::{
    cell::{Cell, RefCell},
    collections::HashMap,
    mem::MaybeUninit,
    ops::DerefMut,
    sync::{atomic::AtomicUsize, Arc},
};
use uvc::{
    ActiveStream, Context, Device, DeviceHandle, DeviceList, Error, FrameFormat as UVCFrameFormat,
    StreamFormat, StreamHandle,
};

#[cfg(feature = "input_uvc")]
impl From<FrameFormat> for UVCFrameFormat {
    fn from(ff: FrameFormat) -> Self {
        match ff {
            FrameFormat::MJPEG => UVCFrameFormat::MJPEG,
            FrameFormat::YUYV => UVCFrameFormat::YUYV,
        }
    }
}

#[cfg(feature = "input_uvc")]
impl From<CameraFormat> for StreamFormat {
    fn from(cf: CameraFormat) -> Self {
        StreamFormat {
            width: cf.width(),
            height: cf.height(),
            fps: cf.framerate(),
            format: cf.format().into(),
        }
    }
}

// ignore the IDE, this compiles
/// The backend struct that interfaces with libuvc.
/// To see what this does, please see [`CaptureBackendTrait`]
/// # Quirks
/// The indexing for this backend is based off of `libuvc`'s device ordering, not the OS.
/// You must call [create()](UVCCaptureDevice::create()) instead `new()`, some methods are auto-generated by the self-referencer and are not meant to be used.
/// The [create()](UVCCaptureDevice::create()) method will open the device twice.
/// Calling [`set_resolution()`](CaptureBackendTrait::set_resolution), [`set_framerate()`](CaptureBackendTrait::set_framerate), or [`set_frameformat()`](CaptureBackendTrait::set_frameformat)
/// each internally calls [`set_camera_format()`](CaptureBackendTrait::set_camera_format).
/// # Safety
/// This backend requires use of `unsafe` due to the self-referencing structs involved.
#[allow(clippy::too_many_arguments)]
#[self_referencing(chain_hack)]
pub struct UVCCaptureDevice<'a> {
    camera_format: Option<CameraFormat>,
    camera_info: CameraInfo,
    frame_receiver: Box<Receiver<Vec<u8>>>,
    frame_sender: Box<Sender<Vec<u8>>>,
    context: Box<Context<'a>>,
    stream_handle_init: Cell<bool>,
    active_stream_init: Cell<bool>,
    #[borrows(context)]
    #[not_covariant]
    device: Box<Device<'this>>,
    #[borrows(device)]
    #[not_covariant]
    device_handle: Box<DeviceHandle<'this>>,
    #[borrows(device_handle)]
    #[not_covariant]
    stream_handle: Box<RefCell<MaybeUninit<StreamHandle<'this>>>>,
    #[borrows(stream_handle)]
    #[not_covariant]
    active_stream: Box<RefCell<MaybeUninit<ActiveStream<'this, Arc<AtomicUsize>>>>>,
}

impl<'a> UVCCaptureDevice<'a> {
    /// Creates a UVC Camera device with optional [`CameraFormat`].
    /// # Panics
    /// This operation may panic! If the UVC Context fails to retrieve the device from the gotten IDs, this operation will panic.
    /// # Errors
    /// This may error when the `libuvc` backend fails to retreive the device or its data.
    pub fn create(index: usize, camera_format: Option<CameraFormat>) -> Result<Self, NokhwaError> {
        let context = match Context::new() {
            Ok(ctx) => Box::new(ctx),
            Err(why) => return Err(NokhwaError::CouldntOpenDevice(why.to_string())),
        };

        let (camera_info, frame_receiver, frame_sender, vendor_id, product_id, serial) = {
            let device_list = match context.devices() {
                Ok(device_list) => device_list,
                Err(why) => return Err(NokhwaError::CouldntOpenDevice(why.to_string())),
            };

            let device = match device_list.into_iter().nth(index) {
                Some(d) => Box::new(d),
                None => {
                    return Err(NokhwaError::CouldntOpenDevice(format!(
                        "Device at {} not found",
                        index
                    )))
                }
            };

            let device_desc = match device.description() {
                Ok(desc) => desc,
                Err(why) => return Err(NokhwaError::CouldntOpenDevice(why.to_string())),
            };

            let device_name = match (device_desc.manufacturer, device_desc.product) {
                (Some(manu), Some(prod)) => {
                    format!("{} {}", manu, prod)
                }
                (_, Some(prod)) => prod,
                (Some(manu), _) => {
                    format!(
                        "{}:{} {}",
                        device_desc.vendor_id, device_desc.product_id, manu
                    )
                }
                (_, _) => {
                    format!("{}:{}", device_desc.vendor_id, device_desc.product_id)
                }
            };

            let camera_info = CameraInfo::new(
                device_name,
                "".to_string(),
                format!("{}:{}", device_desc.vendor_id, device_desc.product_id),
                index,
            );

            let (vendor_id, product_id, serial) = (
                Some(i32::from(device_desc.product_id)),
                Some(i32::from(device_desc.vendor_id)),
                device_desc.serial_number,
            );

            let (frame_sender, frame_receiver) = {
                let (a, b) = flume::unbounded::<Vec<u8>>();
                (Box::new(a), Box::new(b))
            };
            (
                camera_info,
                frame_receiver,
                frame_sender,
                vendor_id,
                product_id,
                serial,
            )
        };

        Ok(UVCCaptureDeviceBuilder {
            camera_format,
            camera_info,
            frame_receiver,
            frame_sender,
            context,
            stream_handle_init: Cell::new(false),
            active_stream_init: Cell::new(false),
            device_builder: |context_builder| {
                Box::new(
                    context_builder
                        .find_device(vendor_id, product_id, serial.as_deref())
                        .unwrap(),
                )
            },
            device_handle_builder: |device_builder| Box::new(device_builder.open().unwrap()),
            stream_handle_builder: |_device_handle_builder| {
                Box::new(RefCell::new(MaybeUninit::uninit()))
            },
            active_stream_builder: |_stream_handle_builder| {
                Box::new(RefCell::new(MaybeUninit::uninit()))
            },
        }
        .build())
    }

    /// Create a UVC Camera with desired settings.
    /// # Panics
    /// This operation may panic! If the UVC Context fails to retrieve the device from the gotten IDs, this operation will panic.
    /// # Errors
    /// This may error when the `libuvc` backend fails to retreive the device or its data.
    pub fn create_with(
        index: usize,
        width: u32,
        height: u32,
        fps: u32,
        fourcc: FrameFormat,
    ) -> Result<Self, NokhwaError> {
        let camera_format = Some(CameraFormat::new_from(width, height, fourcc, fps));
        UVCCaptureDevice::create(index, camera_format)
    }
}

// IDE Autocomplete ends here. Do not be afraid it your IDE does not show completion.
// Here are some docs to help you out: https://docs.rs/ouroboros/0.9.3/ouroboros/attr.self_referencing.html
impl<'a> CaptureBackendTrait for UVCCaptureDevice<'a> {
    fn get_info(&self) -> CameraInfo {
        self.borrow_camera_info().clone()
    }

    fn init_camera_format_default(&mut self, overwrite: bool) -> Result<(), NokhwaError> {
        let camera_format = CameraFormat::default();

        self.with_mut(|fields| {});

        Ok(())
    }

    fn get_camera_format(&self) -> Option<CameraFormat> {
        todo!()
    }

    fn get_compatible_list_by_resolution(
        &self,
        fourcc: FrameFormat,
    ) -> Result<HashMap<Resolution, Vec<u32>>, NokhwaError> {
        todo!()
    }

    fn get_resolution_list(&self, fourcc: FrameFormat) -> Result<Vec<Resolution>, NokhwaError> {
        todo!()
    }

    fn set_camera_format(&mut self, new_fmt: CameraFormat) -> Result<(), NokhwaError> {
        let ret: Result<(), NokhwaError> = self.with_mut(|fields| {
            *fields.camera_format = Some(new_fmt);
            let is_streamh_some = { fields.stream_handle_init.get() };
            if is_streamh_some {
                // TODO
            }

            Ok(())
        });
        Ok(())
    }

    fn get_resolution(&self) -> Option<Resolution> {
        self.with_camera_format(|fmt| fmt.as_ref().map(CameraFormat::resoltuion))
    }

    fn set_resolution(&mut self, new_res: Resolution) -> Result<(), NokhwaError> {
        todo!()
    }

    fn get_framerate(&self) -> Option<u32> {
        self.with_camera_format(|fmt| fmt.as_ref().map(CameraFormat::framerate))
    }

    fn set_framerate(&mut self, new_fps: u32) -> Result<(), NokhwaError> {
        todo!()
    }

    fn get_frameformat(&self) -> Option<FrameFormat> {
        self.with_camera_format(|fmt| fmt.as_ref().map(CameraFormat::format))
    }

    fn set_frameformat(&mut self, fourcc: FrameFormat) -> Result<(), NokhwaError> {
        todo!()
    }

    fn open_stream(&mut self) -> Result<(), NokhwaError> {
        let ret: Result<(), NokhwaError> = self.with_mut(|fields| {
            let stream_format: StreamFormat = match fields.camera_format {
                Some(fmt) => {
                    let cameraformat: CameraFormat = *fmt;
                    cameraformat.into()
                }
                None => {
                    return Err(NokhwaError::CouldntOpenStream(
                        "Please initialise the CameraFormat first!".to_string(),
                    ))
                }
            };

            // first, drop the existing stream by setting it to None
            {
                match fields.active_stream.try_borrow_mut() {
                    Ok(raw_astream) => {
                        if fields.active_stream_init.get() {
                            std::mem::drop(raw_astream.assume_init());
                            std::mem::drop(raw_astream);
                            *raw_astream = MaybeUninit::uninit();
                            fields.active_stream_init.set(false);
                        }
                    }
                    Err(why) => return Err(NokhwaError::CouldntOpenStream(why.to_string())),
                }

                match fields.stream_handle.try_borrow_mut() {
                    Ok(mut raw_streamh) => {
                        if fields.stream_handle_init.get() {
                            std::mem::drop(raw_streamh.assume_init());
                            std::mem::drop(raw_streamh);
                            *raw_streamh = MaybeUninit::uninit();
                            fields.stream_handle_init.set(false);
                        }
                    }
                    Err(why) => return Err(NokhwaError::CouldntOpenStream(why.to_string())),
                }
            }
            // second, set the stream handle according to the streamformat
            match fields
                .device_handle
                .get_stream_handle_with_format(stream_format)
            {
                Ok(streamh) => match fields.stream_handle.try_borrow_mut() {
                    Ok(mut streamh_raw) => {
                        *streamh_raw = MaybeUninit::new(streamh);
                        fields.stream_handle_init.set(true);
                    }
                    Err(why) => return Err(NokhwaError::CouldntOpenStream(why.to_string())),
                },
                Err(why) => return Err(NokhwaError::CouldntOpenStream(why.to_string())),
            }
            Ok(())
        });

        if ret.is_err() {
            return ret;
        }

        let ret_2: Result<(), NokhwaError> = self.with(|fields| {
            // finally, get the active stream
            let counter = Arc::new(AtomicUsize::new(0));
            let frame_sender: Sender<Vec<u8>> = *(self.with_frame_sender(|send| send)).clone();
            let mut streamh = unsafe {};
            // let active_stream = streamh.start_stream(|frame, _cnt| {}, counter);

            Ok(())
        });
        Ok(())
    }

    fn is_stream_open(&self) -> bool {
        todo!()
    }

    fn get_frame(&mut self) -> Result<ImageBuffer<Rgb<u8>, Vec<u8>>, NokhwaError> {
        todo!()
    }

    fn get_frame_raw(&mut self) -> Result<Vec<u8>, NokhwaError> {
        todo!()
    }

    fn stop_stream(&mut self) -> Result<(), NokhwaError> {
        todo!()
    }
}

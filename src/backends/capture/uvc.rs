use crate::{CameraFormat, CameraInfo, CaptureBackendTrait, FrameFormat, NokhwaError, Resolution};
use flume::{Receiver, Sender};
use image::{ImageBuffer, Rgb};
use ouroboros::self_referencing;
use std::{
    collections::HashMap,
    sync::{atomic::AtomicUsize, Arc},
};
use uvc::{ActiveStream, Context, Device, DeviceHandle, DeviceList, Error, StreamHandle};

// ignore the IDE, this compiles
/// The backend struct that interfaces with libuvc.
/// To see what this does, please see [`CaptureBackendTrait`]
/// # Quirks
/// The indexing for this backend is based off of `libuvc`'s device ordering, not the OS.
/// You must call [`UVCCaptureDevice::create()`] instead of [`UVCCaptureDevice::new()`], some methods are auto-generated by the self-referencer and are not meant to be used.
/// # Safety
/// This backend requires use of `unsafe` due to the self-referencing structs involved.
#[self_referencing(chain_hack, no_doc)]
pub struct UVCCaptureDevice<'a> {
    camera_format: Option<CameraFormat>,
    camera_info: CameraInfo,
    frame_receiver: Box<Receiver<Vec<u8>>>,
    frame_sender: Box<Sender<Vec<u8>>>,
    context: Box<Context<'a>>,
    #[borrows(context)]
    #[not_covariant]
    device: Box<Device<'this>>,
    #[borrows(device)]
    #[not_covariant]
    device_handle: Box<Option<DeviceHandle<'this>>>,
    #[borrows(device_handle)]
    #[not_covariant]
    stream_handle: Box<Option<StreamHandle<'this>>>,
    #[borrows(stream_handle)]
    #[not_covariant]
    active_stream: Box<Option<ActiveStream<'this, Arc<AtomicUsize>>>>,
}

impl<'a> UVCCaptureDevice<'a> {
    /// Creates a UVC Camera device with optional CameraFormat.
    pub fn create(index: usize, camera_format: Option<CameraFormat>) -> Result<Self, NokhwaError> {
        let context = match Context::new() {
            Ok(ctx) => Box::new(ctx),
            Err(why) => return Err(NokhwaError::CouldntOpenDevice(why.to_string())),
        };

        let device_list = match context.devices() {
            Ok(device_list) => device_list,
            Err(why) => return Err(NokhwaError::CouldntOpenDevice(why.to_string())),
        };

        let device = match device_list.into_iter().nth(index) {
            Some(d) => Box::new(d),
            None => {
                return Err(NokhwaError::CouldntOpenDevice(format!(
                    "Device at {} not found",
                    index
                )))
            }
        };

        let device_desc = match device.description() {
            Ok(desc) => desc,
            Err(why) => return Err(NokhwaError::CouldntOpenDevice(why.to_string())),
        };

        let device_name = match (device_desc.manufacturer, device_desc.product) {
            (Some(manu), Some(prod)) => {
                format!("{} {}", manu, prod)
            }
            (_, Some(prod)) => prod,
            (Some(manu), _) => {
                format!(
                    "{}:{} {}",
                    device_desc.vendor_id, device_desc.product_id, manu
                )
            }
            (_, _) => {
                format!("{}:{}", device_desc.vendor_id, device_desc.product_id)
            }
        };

        let camera_info = CameraInfo::new(
            device_name,
            "".to_string(),
            format!("{}:{}", device_desc.vendor_id, device_desc.product_id),
            index,
        );

        let (frame_sender, frame_receiver) = {
            let (a, b) = flume::unbounded::<Vec<u8>>();
            (Box::new(a), Box::new(b))
        };

        Ok(UVCCaptureDeviceBuilder {
            camera_format,
            camera_info,
            frame_receiver,
            frame_sender,
            context,
            device_builder: |_ctx| device,
            device_handle_builder: |_device_builder| Box::new(None),
            stream_handle_builder: |_device_handle_builder| Box::new(None),
            active_stream_builder: |_stream_handle_builder| Box::new(None),
        }
        .build())
    }

    /// Create a UVC Camera with desired settings.
    pub fn create_with(
        index: usize,
        width: u32,
        height: u32,
        fps: u32,
        fourcc: FrameFormat,
    ) -> Result<Self, NokhwaError> {
        let camera_format = Some(CameraFormat::new_from(width, height, fourcc, fps));
        UVCCaptureDevice::create(index, camera_format)
    }
}

// IDE Autocomplete ends here. Do not be afraid it your IDE does not show completion.
// Here are some docs to help you out: https://docs.rs/ouroboros/0.9.3/ouroboros/attr.self_referencing.html
impl<'a> CaptureBackendTrait for UVCCaptureDevice<'a> {
    fn get_info(&self) -> CameraInfo {
        self.borrow_camera_info().clone()
    }

    fn init_camera_format_default(&mut self, overwrite: bool) -> Result<(), NokhwaError> {
        let camera_format = CameraFormat::default();

        self.with_camera_format_mut(|fmt| match fmt {
            Some(existing_fmt) => {
                if overwrite {
                    fmt = &mut Some(camera_format);
                }
            }
            None => {
                fmt = &mut Some(camera_format);
            }
        });

        
    }

    fn get_camera_format(&self) -> Option<CameraFormat> {
        todo!()
    }

    fn get_compatible_list_by_resolution(
        &self,
        fourcc: FrameFormat,
    ) -> Result<HashMap<Resolution, Vec<u32>>, NokhwaError> {
        todo!()
    }

    fn get_resolution_list(&self, fourcc: FrameFormat) -> Result<Vec<Resolution>, NokhwaError> {
        todo!()
    }

    fn set_camera_format(&mut self, new_fmt: CameraFormat) -> Result<(), NokhwaError> {
        todo!()
    }

    fn get_resolution(&self) -> Option<Resolution> {
        todo!()
    }

    fn set_resolution(&mut self, new_res: Resolution) -> Result<(), NokhwaError> {
        todo!()
    }

    fn get_framerate(&self) -> Option<u32> {
        todo!()
    }

    fn set_framerate(&mut self, new_fps: u32) -> Result<(), NokhwaError> {
        todo!()
    }

    fn get_frameformat(&self) -> Option<FrameFormat> {
        todo!()
    }

    fn set_frameformat(&mut self, fourcc: FrameFormat) -> Result<(), NokhwaError> {
        todo!()
    }

    fn open_stream(&mut self) -> Result<(), NokhwaError> {
        todo!()
    }

    fn is_stream_open(&self) -> bool {
        todo!()
    }

    fn get_frame(&mut self) -> Result<ImageBuffer<Rgb<u8>, Vec<u8>>, NokhwaError> {
        todo!()
    }

    fn get_frame_raw(&mut self) -> Result<Vec<u8>, NokhwaError> {
        todo!()
    }

    fn stop_stream(&mut self) -> Result<(), NokhwaError> {
        todo!()
    }
}
